#!/usr/bin/env raku

use Async::Command::Multi;
use Data::Dump::Tree;
use Our::Cache;
use JSON::Fast;

class PHYSICALDISK_RECORD {
    has Str             $.name;
    has Str             $.serial;
    has Str             $.status;
}

class ALERTHISTORY_RECORD {
    has Str             $.name;
    has DateTime        $.datetime;
    has Str             $.precedence;
    has Str             $.message;
}

my @EXADATA-adms;
my %inventory;
my %status;
my %command;
my $id-prefix           = 'DateTime-Last-alerthistory-Record';

my @redis-servers = slurp("$*HOME/.redis-servers").chomp.split("\n");

my @redis-clis;
for @redis-servers -> $redis-server {
    my @cmd-string = sprintf("ssh -L 127.0.0.1:6379:%s:6379 %s /usr/bin/redis-cli", $redis-server, $redis-server).split: /\s+/;
    @redis-clis.push: @cmd-string;
}

for @redis-clis -> @redis-cli {
    my @rcmd        = flat @redis-cli,
                      '--raw',
                      'KEYS',
                      'eb:exadata:adm:*';
    my $proc        = run   @rcmd, :out, :err;
    my $out         = $proc.out.slurp(:close);
    my $err         = $proc.err.slurp(:close);
    fail 'FAILED: ' ~ @rcmd ~ ":\t" ~ $err if $err;
    if $out {
        my @z-keys  = $out.chomp.split("\n");
        die "No EXADATA adm keys!" unless @z-keys;
        @rcmd       = flat @redis-cli,
                      '--raw',
                      'SUNION',
                      @z-keys;
        $proc       = run   @rcmd, :out, :err;
        $out        = $proc.out.slurp(:close);
        $err        = $proc.err.slurp(:close);
        if $err {
            warn 'ERROR: ' ~ @rcmd.join(' ') ~ ":\t" ~ $err;
            next;
        }
        next        unless $out;
        @EXADATA-adms = $out.chomp.split("\n").sort;
        last;
    }
}

sub MAIN (
    Int   :$log-days        = 0,               #= log days to display (bypass "only unseen logs" mechanism)
) {
    die                     unless @EXADATA-adms.elems;
    %command                = ();
    for @EXADATA-adms -> $adm {
        %command{$adm}      = 'ssh', $adm, 'sudo', 'dcli', '-l', 'root', '-g', '/root/cell_group', '"cellcli -e list physicaldisk"';
    }

    my %physicaldisk        = Async::Command::Multi.new(:%command).sow.reap;

    for %physicaldisk.keys.sort -> $adm {
        for %physicaldisk{$adm}.stdout-results.lines -> $record {
            my @fields      = $record.trim.split(/\s+/);
            my $node        = @fields[0].ends-with(':') ?? @fields[0].chop(1) !! @fields[0];
            %inventory{$adm}{$node} = '';
            %status{$adm}<PHYSICALDISK>{$node}.push: PHYSICALDISK_RECORD.new:
                :name(@fields[1]),
                :serial(@fields[2]),
                :status(@fields[3..*].join(' '));
        }
    }

    my $identifier          = 'alerthistory_datetimes';
    my %ah-dt-cache;
    my $ah-dt-cache         = Our::Cache.new(:$identifier);

    if ! $log-days && $ah-dt-cache.cache-hit {
        %ah-dt-cache        = from-json($ah-dt-cache.fetch) or note $?LINE;
        for %ah-dt-cache.keys.sort -> $adm {
            for %ah-dt-cache{$adm}.keys.sort -> $node {
                %ah-dt-cache{$adm}{$node} = DateTime.new: %ah-dt-cache{$adm}{$node};
            }
        }
    }
    else {
        my $first-log       = now - (365 * 24 * 60 * 60);
        $first-log          = now - ($log-days * 24 * 60 * 60) if $log-days;
        my $first-dt        = DateTime.new(:timezone($*TZ), $first-log).truncated-to('second');
        for %inventory.keys.sort -> $adm {
            for %inventory{$adm}.keys.sort -> $node {
                %ah-dt-cache{$adm}{$node} = $first-dt.clone;
            }
        }
        $ah-dt-cache.store(:data(to-json(%ah-dt-cache)));
    }

    %command                = ();
    for %inventory.keys -> $adm {
        for %inventory{$adm}.keys.sort -> $cell {
            %command{$cell} = (
                                'ssh',
                                $adm,
                                'sudo',
                                'ssh',
                                $cell,
                                Q/"cellcli -e list alerthistory WHERE begintime \\> \\'/ ~ %ah-dt-cache{$adm}{$cell}.Str ~ Q/\\'"/,
                            );
        }
    }

    my %alerthistory        = Async::Command::Multi.new(:%command).sow.reap;

    for %inventory.keys -> $adm {
        for %inventory{$adm}.keys.sort -> $cell {
            for %alerthistory{$cell}.stdout-results.lines -> $record {
put $record;
next;
                my @fields      = $record.trim.split(/\s+/);
                my $datetime    = DateTime.new(@fields[1]);
                %ah-dt-cache{$adm}{$cell} = $datetime if $datetime > %ah-dt-cache{$adm}{$cell};
                %status{$adm}<ALERTHISTORY>{$cell}.push: ALERTHISTORY_RECORD.new:
                    :name(@fields[0]),
                    :$datetime,
                    :precedence(@fields[2]),
                    :message(@fields[3..*].join(' '));
            }
        }
    }
die;

    $ah-dt-cache.store(:data(to-json(%ah-dt-cache)));

    for %inventory.keys -> $adm {
        put $adm;
        for %inventory{$adm}.keys.sort -> $cell {
            put "\t" ~ $cell;
            for %status{$adm}<PHYSICALDISK>{$cell}.list -> $pd {
                printf "\t\t%s\t%s [%s]\n", $pd.status, $pd.name, $pd.serial if $pd.status ne 'normal';
            }
            if (%status{$adm}<ALERTHISTORY>:exists) && (%status{$adm}<ALERTHISTORY>{$cell}:exists) {
                for %status{$adm}<ALERTHISTORY>{$cell}.list -> $logrcd {
                    printf "\t\t%s %s %s\n", $logrcd.datetime, $logrcd.precedence, $logrcd.message;
                }
            }
        }
    }
}

=finish

grammar EXADATALOG {
    
}
    3_1    2025-08-30T03:06:44-04:00    info        Advanced Intrusion Detection Environment (AIDE) detected potential changes to software on this system. The changes are listed in /var/log/aide/aide.log and also at the end of this alert message.
                                                    Summary : :
                                                    Total number of entries : 54096
                                                    Added entries : 1
                                                    Removed entries : 0
                                                    Changed entries : 0
    1_1    2025-08-14T07:18:41-04:00    critical    After initial accelerated space reclamation, file system / is 80% full, which is equal to or above the 80% threshold. Accelerated space reclamation will continue.
                                                    This alert will be cleared when file system / becomes less than 75% full.
                                                    Top three directories ordered by total space usage are as follows:
                                                    /opt        : 2.69G
                                                    /root        : 2.15G
                                                    /usr        : 1.76G
    1_2    2025-08-14T17:36:40-04:00    clear       File system / is 58% full, which is below the 75% threshold. Normal space reclamation will resume.

my grammar EXADATALOG-grammar {
    token TOP {
        ^
        \s+
        <log-record>+
    }
    token log-record {
        <name-field>
        \s+
        <datetime-field>
        \s+
        <status-field>
        \s+
        <message-field>
}


        $$ \n
        ^^ \s+
        <active-field>
        <os-field>
        .+?
        $$ \n
    }
    token record-number-field   { '<#' <record-number> '>'          }
    token record-number         { \d+                               }
    token partition-field       {
                                    Partition ':<'
                                    <partition-number>
                                    '*'
                                    <model-type>
                                    '*'
                                    <serial-number>
                                    ',' \s+
                                    <ip-label>*
                                    ',' \s+
                                    <ip-address>
                                    '>'
                                }
    token partition-number      { \d+                               }
    token model-type            { <model> '-' <type>                }
    token model                 { \w ** 4                           }
    token type                  { \w ** 3                           }
    token serial-number         { \w ** 7                           }
    token ip-label              { <-[,]>+                           }
    token ip-address            { <ip-address-octet> ** 4 %% '.'    }
    token ip-address-octet      { \d ** 1..3                        }
    token active-field          { Active ':<' <active> '>,' \s+     }
    token active                { \d                                }
    token os-field              {
                                    OS ':<'
                                    <os-name>
                                    ',' \s+
                                    <os-vr>
                                    ',' \s+
                                    <os-level>
                                    '>'
                                }

#   OS:<, , >,

    token os-name               { <-[,]>*                           }
    token os-vr                 { <-[,]>*                           }
    token os-level              { <-[\>]>*                          }
}

class LSPPARTITIONDLPAR-actions {
    has $.hmc is required;

    method dlpar-record ($/) {
        my Int $partition-number    = +$/<partition-field><partition-number>;
        %HMC{$!hmc}<LSPPARTITIONDLPAR>{$partition-number} = LSPPARTITIONDLPAR.new:
            :$partition-number,
            :model(~$/<partition-field><model-type><model>),
            :type(~$/<partition-field><model-type><type>),
            :serial-number(~$/<partition-field><serial-number>),
            :ip-address(~$/<partition-field><ip-address>),
            :active(?$/<active-field><active>),
            :os-name(~$/<os-field><os-name>),
            :os-vr(~$/<os-field><os-vr>),
            :os-level(~$/<os-field><os-level>),
        ;

    }
}
